#This is the command telling CMake to enforce a minimum version requirement.
cmake_minimum_required(VERSION 3.10)


#Define all the possible colors to be used Text colors and background colors 
set(CMAKE_COLOR_RESET "\\033[0m")
set(CMAKE_COLOR_BLACK "\\033[30m")
set(CMAKE_COLOR_RED "\\033[31m")
set(CMAKE_COLOR_GREEN "\\033[32m")
set(CMAKE_COLOR_YELLOW "\\033[33m")
set(CMAKE_COLOR_BLUE "\\033[34m")
set(CMAKE_COLOR_MAGENTA "\\033[35m")
set(CMAKE_COLOR_CYAN "\\033[36m")
set(CMAKE_COLOR_WHITE "\\033[37m")

set(CMAKE_BG_BLACK "\\033[40m")
set(CMAKE_BG_RED "\\033[41m")
set(CMAKE_BG_GREEN "\\033[42m")
set(CMAKE_BG_YELLOW "\\033[43m")
set(CMAKE_BG_BLUE "\\033[44m")
set(CMAKE_BG_MAGENTA "\\033[45m")
set(CMAKE_BG_CYAN "\\033[46m")
set(CMAKE_BG_WHITE "\\033[47m")

# Print during the Cmake Environemt generation to ensure that the used Cmake is higher than the required minumm "3.10"
message("Reached here after the version check")

# The Most Used API as it sets many of the Default variables to be used as shown below:

#(1) Project Name: It sets the name of your project, which can be used later in variables like ${PROJECT_NAME}. This is helpful for generating consistent output file names or displaying messages.

#(2) Default Directories: It implicitly defines several important directories within your build tree, even if you don't see them explicitly defined:

# CMAKE_BINARY_DIR: This variable will point to the top-level directory of your build tree (where you ran CMake).
# CMAKE_SOURCE_DIR: This variable will point to the top-level directory of your source code (where your top-level CMakeLists.txt resides).
# CMAKE_CURRENT_BINARY_DIR: This variable is particularly useful, as it always points to the directory of the currently processed CMakeLists.txt file. # This is important when you have subdirectories with their own CMakeLists.txt files.

project(cmake_project )

# Inluce the .cmake file named "swc_paths.cmake" which will have all the relative paths will be used in the Cmake generation 
include(swc_paths.cmake)
# Include the toolchain file
#This is the command in CMake used to incorporate external CMake files into your project which are the Tool chain Cmake for AVR Microcontrollers (Compilers,linker scripts and others)
include(avr.cmake)

# Target-specific settings
# This is a compiler flag specifically for GCC (GNU Compiler Collection), which is commonly used for AVR development. It tells the compiler that the target microcontroller is an ATmega16. This is crucial because the following :

# => Instruction Set: The compiler needs to know the specific instruction set of the ATmega16 to # generate the correct machine code.
# => Memory Layout: The compiler needs to understand the ATmega16's memory organization (flash, # RAM, EEPROM) to place code and data correctly.
# => Registers: The compiler uses this information to access the ATmega16's specific registers #(like PORTB, DDRB, etc.) correctly

# => -Os: This is another compiler flag for GCC. It stands for "Optimize for size." When this flag is used, the compiler prioritizes generating the smallest possible executable file size, even if it means slightly sacrificing execution speed. This is often desirable for embedded systems like those using AVR microcontrollers, where memory space is limited.
add_definitions(-mmcu=atmega16 -Os)

# Print the AVR Tool chain path to make sure that Cmake build environment is generated by the AVR TOOL Chain   
message("THe Avr Tool chain path is :${AVR_TOOLCHAIN_PATH}")
# Check if the AVR_TOOLCHAIN_PATH is sit correctely in the path {/opt/AVR_Tool_Chain/avr8-gnu-toolchain-linux_x86_64} or there will be a FATAL ERROR during Cmake build environmet Generation 
if(NOT AVR_TOOLCHAIN_PATH STREQUAL "/opt/AVR_Tool_Chain/avr8-gnu-toolchain-linux_x86_64")
  message(FATAL_ERROR "AVR Toolchain path is incorrect. Please set AVR_TOOLCHAIN_PATH to '/opt/AVR_Tool_Chain/avr8-gnu-toolchain-linux_x86_64'.")
endif()
# Print the selected C Compiler path from the AVR toolschain during the Cmake build environemt generation  
message("The compiler path gcc is : ${CMAKE_C_COMPILER}")
# Print the selected C ++ Compiler path from the AVR toolschain during the Cmake build environemt generation  
message("THE c++ COMPILER PATH IS : ${CMAKE_CXX_COMPILER}")



# This is a CMake command that adds directories to the compiler's search path for include files. When your code has a line like #include "some_header.h", the compiler will search in these specified directories to find 
include_directories(${SWC_one})
include_directories(${SWC_two})

# Fast Soluation to be used to list all the .c files in the SW to be built if this is wanted to be done 
#file(...): This is the general CMake command for performing file system operations.
#GLOB_RECURSE: This is the keyword telling CMake to perform file globbing and to do it recursively. This means #it will search not only in the specified directory (src_code/ in this case) but also in all its #subdirectories.
#SOURCES: This is the variable where the list of found files will be stored. You can choose any variable name #you want.
#"src_code/*.c": This is the glob pattern used to search for files.
#src_code/: This part specifies the starting directory for the search.
#*.c: This is a wildcard pattern. It means "find all files ending in .c".
file(GLOB_RECURSE SOURCES "src_code/*.c")


# Add the executable for only the main.c file as the other SWCs will be linked staticly (.a) by using the add_subdirectory (SWC name )
#add_executable(...): This is the CMake command that tells CMake to create an executable file.
#final: This is the name you've chosen for your executable. When the project is built, the output executable file will be named "final".
#src_code/main.c: This is the path to your main source code file, relative to the directory where your top-level CMakeLists.txt file #is located. CMake will use this file as the entry point for building your executable.
add_executable(final ${main})

# This the CmakeLists Commands used to compile other SWC and Create a static Libirary form them (SWC_example.a) ready to belinked in your final exeutable at the end 
#These are CMake commands that tell CMake to look for other CMakeLists.txt files within the specified subdirectories and when it find one then it performs the follwoing 
#(1) Subdirectory Search: CMake will go into the specified subdirectory and search for a file named CMakeLists.txt.
#(2) Subproject Processing: If found, CMake will process the CMakeLists.txt file in that subdirectory as if it were a separate CMake project. This allows you to define targets (executables, libraries), set compiler flags, include directories, and perform other CMake operations specific to that subdirectory.
add_subdirectory(${SWC_one})
add_subdirectory(${SWC_two})


# Here will be listed all the SWCs which will be linked in just one cmake variable to be used easliy 
set(Linked_SWcs SWC_one SWC_two)



#The below line is very risky specially the Tdata part it gives the begging the .data section addresse 
#This line is crucial for linking your executable to the static libraries you've created for your AVR project and for influencing the memory layout of your program.
# the command instructs CMake to link the final executable with the SWC_one and SWC_two static libraries. CMake will handle the details of finding the libraries and ensuring they are linked in the correct order during the build process.
# the below line will set all the required liner flags to be used during linking stage 
set_target_properties(final PROPERTIES
    LINK_FLAGS "-Wl,-Ttext=0x0000 -Wl,-Tdata=0x800060"
)
#The line below will list all the SWCs which willbe linked staticly to the final generated 
target_link_libraries(final ${Linked_SWcs})

# Set output formats to generate hex file from the obj
# set_target_properties(final PROPERTIES
#     SUFFIX ".hex"
#     LINK_FLAGS "-Wl,-Map=final.map"
#     COMMENT "Generating HEX file..."
# )
add_custom_target(final_hex
    COMMAND ${AVR_OBJCOPY} -O ihex final.elf final.hex 
    DEPENDS final # Ensure the 'final' target is built first
    COMMENT "Generating HEX file using avr-objcopy...âœ…âœ…âœ…âœ…"
)

# Add a custom target for ELF generation
add_custom_target(final_elf
    # COMMAND echo "${CMAKE_COLOR_CYAN}${CMAKE_BG_MAGENTA}START OF ELF FILE Generation ðŸŽ‰${CMAKE_COLOR_RESET}"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_CURRENT_BINARY_DIR}/tmp" 
    COMMAND ${CMAKE_COMMAND} -E echo "$<TARGET_OBJECTS:final> $<TARGET_OBJECTS:SWC_one> $<TARGET_OBJECTS:SWC_two>" > "${CMAKE_CURRENT_BINARY_DIR}/tmp/object_files.txt"
    COMMAND sed -i "s/;/ /g" "${CMAKE_CURRENT_BINARY_DIR}/tmp/object_files.txt" # Correctly quoted sed command
    COMMAND ${CMAKE_C_COMPILER} -mmcu=atmega16 -Wl,-Map=final.map -o final.elf  @${CMAKE_CURRENT_BINARY_DIR}/tmp/object_files.txt 
    DEPENDS final ${Linked_SWcs} 
    COMMENT "Generating ELF file...âœ…âœ…âœ…âœ…âœ…"
    # COMMAND echo "${CMAKE_COLOR_CYAN}${CMAKE_BG_MAGENTA}END OF ELF FILE Generation ðŸŽ‰${CMAKE_COLOR_RESET}"
    VERBATIM
)








